use crate::{RelationOp, ArithmeticOp, Expression, Spanned, SpanExtension, UnaryOp, Member, Atom, parse_bytes, parse_string};
use std::sync::Arc;

grammar;

match {
    // Skip whitespace and comments
   r"\s*" => { },
   r"//[^\n\r]*[\n\r]*" => { },
} else {
   _
}

pub SpannedExpression: Spanned<Expression> = {
    Expression
};

pub Expression: Spanned<Expression> = {
    Conditional
};

pub Conditional: Spanned<Expression> = {
    <start: @L> <condition:LogicalOr> "?" <if_true:LogicalOr> ":" <if_false:Conditional> <end: @R> => Expression::Ternary(condition.into(), if_true.into(), if_false.into()).spanned(start..end),
    LogicalOr
};

pub LogicalOr: Spanned<Expression> = {
    <start: @L> <left:LogicalOr> "||" <right:LogicalAnd> <end: @R> => Expression::Or(left.into(), right.into()).spanned(start..end),
    LogicalAnd
};

pub LogicalAnd: Spanned<Expression> = {
    <start: @L> <left:LogicalAnd> "&&" <right:Relations> <end: @R> => Expression::And(left.into(), right.into()).spanned(start..end),
    Relations
};

pub Relations: Spanned<Expression> = {
    <start: @L> <left:ArithmeticAddSub> <op:SpannedRelationOp> <right:ArithmeticAddSub> <end: @R> => Expression::Relation(left.into(), op, right.into()).spanned(start..end),
    ArithmeticAddSub
};

pub ArithmeticAddSub: Spanned<Expression> = {
    <start: @L> <left:ArithmeticAddSub> <op:SpannedArithmeticOpAddSub> <right:ArithmeticMulDivMod> <end: @R> => Expression::Arithmetic(left.into(), op, right.into()).spanned(start..end),
    ArithmeticMulDivMod
};

pub ArithmeticMulDivMod: Spanned<Expression> = {
    <start: @L> <left:ArithmeticMulDivMod> <op:SpannedArithmeticOpMulDivMod> <right:Unary> <end: @R> => Expression::Arithmetic(left.into(), op, right.into()).spanned(start..end),
    Unary
};

pub Unary: Spanned<Expression> = {
    <start: @L> <op:SpannedUnaryOp> <right:Member> <end: @R> => Expression::Unary(op, right.into()).spanned(start..end),
    Member
};

pub Member: Spanned<Expression> = {
    <start: @L> <left:Member> "." <identifier:Ident> <end: @R> => Expression::Member(left.into(), Member::Attribute(identifier.into()).into()).spanned(start..end),
    <start: @L> <left:Member> "." <identifier:ExprIdent> "(" <arguments:CommaSeparated<SpannedExpression>> ")" <end: @R> => {
           Expression::FunctionCall(identifier.into(), Some(left.into()), arguments).spanned(start..end)
   },
    <start: @L> <left:Member> "[" <expression:SpannedExpression> "]" <end: @R> => Expression::Member(left.into(), Member::Index(expression.into()).into()).spanned(start..end),
    <start: @L> <left:Member> "{" <fields:CommaSeparated<FieldInits>> "}" <end: @R> => Expression::Member(left.into(), Member::Fields(fields.into()).into()).spanned(start..end),
    Primary,
}

pub Primary: Spanned<Expression> = {
    <start: @L> "."? <id: Ident> <end: @R> => Expression::Ident(id.into()).spanned(start..end),
    <start: @L> "."? <identifier:ExprIdent> "(" <arguments:CommaSeparated<SpannedExpression>> ")" <end: @R> => {
           Expression::FunctionCall(identifier.into(), None, arguments).spanned(start..end)
    },
    <start: @L> <a: Atom> <end: @R> => Expression::Atom(a).spanned(start..end),
    <start: @L> "[" <members:CommaSeparated<SpannedExpression>> "]" <end: @R> => Expression::List(members).spanned(start..end),
    <start: @L> "{" <fields:CommaSeparated<MapInits>> "}" <end: @R> => Expression::Map(fields).spanned(start..end),
    "(" <Expression> ")"
}

pub FieldInits: (Arc<Spanned<String>>, Spanned<Expression>) = {
    <Ident> ":" <SpannedExpression>
}

pub MapInits: (Spanned<Expression>, Spanned<Expression>) = {
    <SpannedExpression> ":" <SpannedExpression>
}

CommaSeparated<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SpannedArithmeticOpAddSub: Spanned<ArithmeticOp> = {
    <start: @L> <op: ArithmeticOpAddSub> <end: @R> => op.spanned(start..end)
};

ArithmeticOpAddSub: ArithmeticOp = {
    "+" => ArithmeticOp::Add,
    "-" => ArithmeticOp::Subtract
};

SpannedArithmeticOpMulDivMod: Spanned<ArithmeticOp> = {
    <start: @L> <op: ArithmeticOpMulDivMod> <end: @R> => op.spanned(start..end)
};

ArithmeticOpMulDivMod: ArithmeticOp = {
    "*" => ArithmeticOp::Multiply,
    "/" => ArithmeticOp::Divide,
    "%" => ArithmeticOp::Modulus
};


SpannedUnaryOp: Spanned<UnaryOp> = {
    <start: @L> <op: UnaryOp> <end: @R> => op.spanned(start..end)
};

UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
    "!!" => UnaryOp::DoubleNot,
    "-" => UnaryOp::Minus,
    "--" => UnaryOp::DoubleMinus,
};

SpannedRelationOp: Spanned<RelationOp> = {
    <start: @L> <op: RelationOp> <end: @R> => op.spanned(start..end)
};

RelationOp: RelationOp = {
    "<" => RelationOp::LessThan,
    "<=" => RelationOp::LessThanEq,
    ">" => RelationOp::GreaterThan,
    ">=" => RelationOp::GreaterThanEq,
    "==" => RelationOp::Equals,
    "!=" => RelationOp::NotEquals,
    "in" => RelationOp::In
};

Atom: Atom = {
    // Integer literals. Annoying to parse :/
    r"-?[0-9]+" => Atom::Int(<>.parse().unwrap()),
    <s:r"-?0[xX][0-9a-fA-F]+"> => Atom::Int(i64::from_str_radix(&s.chars().filter(|&x| x != 'x' && x != 'X').collect::<String>(), 16).unwrap()),
    <s:r"[0-9]+[uU]"> => Atom::UInt(s[..s.len()-1].parse().unwrap()),
    <s:r"-?0[xX][0-9a-fA-F]+[uU]"> => Atom::UInt(u64::from_str_radix(&s.chars().filter(|&x| x != 'x' && x != 'X' && x != 'u' && x != 'U').collect::<String>(), 16).unwrap()),

    // Float with decimals and optional exponent
    r"([-+]?[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?)" => Atom::Float(<>.parse().unwrap()),
    // Float with no decimals and required exponent
    r"[-+]?[0-9]+[eE][-+]?[0-9]+" => Atom::Float(<>.parse().unwrap()),

    // NOTE: I've commented out some of the more complex string parsing rules
    // because they're causing "attempt to subtract with overflow" errors within
    // the LALRPOP parser.

    // Double quoted string
    // I used ChatGPT to come up with this pattern and the explanation is as follows:
    //   1. `"`: Match the opening double quote.
    //   2. `([^"\\]*(?:\\.[^"\\]*)*)`: This is the main part of the regex which matches the content inside the double quotes.
    //     a. `[^"\\]*`: Match any sequence of characters that are neither a double quote nor a backslash.
    //     b. `(?:\\.[^"\\]*)*`: This part matches an escaped character followed by any sequence of characters that are
    //        neither a double quote nor a backslash. It uses a non-capturing group (?:...) to repeat the pattern.
    //        This handles sequences like \", \\, or any other escaped character.
    //   3. `"`: Match the closing double quote.
    r#""([^"\\]*(?:\\.[^"\\]*)*)""# => Atom::String(parse_string(<>).unwrap().into()),
    r#"[rR]"([^"\\]*(?:\\.[^"\\]*)*)""# => Atom::String(parse_string(<>).unwrap().into()),
    // r#""""(\\.|[^"{3}])*""""# => Atom::String(<>.to_string().into()),

    // Single quoted string
    // Uses similar regex as above, but replace double quote with a single one
    r#"'([^'\\]*(?:\\.[^'\\]*)*)'"# => Atom::String(parse_string(<>).unwrap().into()),
    r#"[rR]'([^'\\]*(?:\\.[^'\\]*)*)'"# => Atom::String(parse_string(<>).unwrap().into()),
    // r#"'''(\\.|[^'{3}])*'''"# => Atom::String(<>.to_string().into()),

    // Double quoted bytes
    r#"[bB]"(\\.|[^"\n])*""# => Atom::Bytes(parse_bytes(&<>[2..<>.len()-1]).unwrap().into()),
    // r#"[bB]"""(\\.|[^"{3}])*""""# => Atom::Bytes(Vec::from(<>.as_bytes()).into()),

    // Single quoted bytes
    r#"[bB]'(\\.|[^'\n])*'"# => Atom::Bytes(parse_bytes(&<>[2..<>.len()-1]).unwrap().into()),
    // r#"[bB]'''(\\.|[^'{3}])*'''"# => Atom::Bytes(Vec::from(<>.as_bytes()).into()),

    "true" => Atom::Bool(true),
    "false" => Atom::Bool(false),
    "null" => Atom::Null,
};

ExprIdent: Spanned<Expression> = {
    <start: @L> <id: Ident> <end: @R> => Expression::Ident(id).spanned(start..end)
}

Ident: Arc<Spanned<String>> = {
    <start: @L> <s: r"[_a-zA-Z][_a-zA-Z0-9]*"> <end: @R> => Arc::from(s.to_string().spanned(start..end))
}